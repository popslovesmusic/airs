--- a/src/cpp/igsoa_state_init_2d.h
+++ b/src/cpp/igsoa_state_init_2d.h
@@ -265,21 +265,33 @@
         const auto& nodes = engine.getNodes();

         double sum_F = 0.0;
-        double sum_x_F = 0.0;
-        double sum_y_F = 0.0;
+        // Use circular statistics for toroidal topology
+        double sum_cos_x = 0.0;
+        double sum_sin_x = 0.0;
+        double sum_cos_y = 0.0;
+        double sum_sin_y = 0.0;

         for (size_t y = 0; y < N_y; y++) {
             for (size_t x = 0; x < N_x; x++) {
                 size_t index = y * N_x + x;
                 double F = nodes[index].F;

+                // Convert coordinates to angles on unit circle
+                double theta_x = 2.0 * M_PI * static_cast<double>(x) / static_cast<double>(N_x);
+                double theta_y = 2.0 * M_PI * static_cast<double>(y) / static_cast<double>(N_y);
+
                 sum_F += F;
-                sum_x_F += static_cast<double>(x) * F;
-                sum_y_F += static_cast<double>(y) * F;
+                sum_cos_x += F * std::cos(theta_x);
+                sum_sin_x += F * std::sin(theta_x);
+                sum_cos_y += F * std::cos(theta_y);
+                sum_sin_y += F * std::sin(theta_y);
             }
         }

         if (sum_F > 0.0) {
-            x_cm_out = sum_x_F / sum_F;
-            y_cm_out = sum_y_F / sum_F;
+            // Compute mean angle using atan2
+            double mean_theta_x = std::atan2(sum_sin_x, sum_cos_x);
+            double mean_theta_y = std::atan2(sum_sin_y, sum_cos_y);
+
+            // Convert back to coordinates (ensure positive result)
+            x_cm_out = static_cast<double>(N_x) * mean_theta_x / (2.0 * M_PI);
+            if (x_cm_out < 0.0) x_cm_out += static_cast<double>(N_x);
+
+            y_cm_out = static_cast<double>(N_y) * mean_theta_y / (2.0 * M_PI);
+            if (y_cm_out < 0.0) y_cm_out += static_cast<double>(N_y);
         } else {
